// BOARD: Adafruit Huzzah32 Feather

// IMPORTS
#include <SPI.h>
#include <Wire.h>

#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <Adafruit_LIS3DH.h>
#include <Adafruit_Sensor.h>

// OLED INIT
#define SCREEN_WIDTH 128
#define SCREEN_HEIGHT 64
#define OLED_RESET -1
#define SCREEN_ADDRESS 0x3D
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

// LIS3DH INIT
Adafruit_LIS3DH lis = Adafruit_LIS3DH();

// LIPOLY INIT
#define BATTERY_PIN 35
#define VOLTAGE_DIVIDER_RATIO 2
#define REFERENCE_VOLTAGE 3.3

// Step Detection Parameters
#define accelBufferSize 100
int stepCount = 0;
float buffer[accelBufferSize];
int bufferIndex = 0;
float K = 12.5; // min threshold to be considered a step

void countPeaks() {
  // Algorithm in paper calculated mean and used a fraction of it as a threshold
  // But in experimentation, this seemed to just add computation time without affective accuracy

  for (int i = 1; i < accelBufferSize - 1; i++) {
    float forwardSlope = buffer[i+1] - buffer[i];
    float backwardSlope = buffer[i] - buffer[i-1];
    if (forwardSlope < 0 && backwardSlope > 0 &&
        buffer[i] > K) {
      stepCount ++;
    }
  }
};

// Smoothing Parameters
#define FILTER_SIZE 5
float filterBuffer[FILTER_SIZE];
int filterIndex = 0; 

float smoothAccel(float accel) {
  filterBuffer[filterIndex] = accel;
  filterIndex = (filterIndex + 1) % FILTER_SIZE;
  float filteredAccel = 0;
  for (int i = 0; i < FILTER_SIZE; i++) {
    filteredAccel += filterBuffer[i];
  }
  return filteredAccel / FILTER_SIZE;
}

#define TEXT_TIME 4000   // milliseconds stat screen of text will be displayed
#define HEART_TIME 6000  // milli seconds heart screen will be displayed
int lastStepCount = 0;
unsigned long lastSwitchTime = 0;
unsigned long waitTime = TEXT_TIME;
bool isHeartDisplayed = false;

// if only you knew how much blood sweat and Mountain Dew went into this
const unsigned char heart_bitmap[512] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x01, 0xf0, 0x00, 0x00, 0x0f, 0x80, 0x00, 0x00, 0x03, 0xfc, 0x00, 0x00, 0x3f, 0xc0, 0x00, 
  0x00, 0x0f, 0xff, 0x00, 0x00, 0xff, 0xf0, 0x00, 0x00, 0x1f, 0xff, 0xc0, 0x03, 0xff, 0xf8, 0x00, 
  0x00, 0x7f, 0xff, 0xe0, 0x07, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xf0, 0x0f, 0xff, 0xfe, 0x00, 
  0x00, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0x00, 0x01, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0x80, 
  0x03, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xc0, 
  0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x07, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 
  0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 
  0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 
  0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 
  0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 
  0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 
  0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 
  0x00, 0x0f, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x07, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 
  0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
  0x00, 0x00, 0x7f, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xfc, 0x00, 0x00, 
  0x00, 0x00, 0x0f, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x07, 0xff, 0xff, 0xe0, 0x00, 0x00, 
  0x00, 0x00, 0x01, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x3f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0xf0, 0x00, 0x00, 0x00
};

unsigned char revealed_bitmap[512] PROGMEM; // array to hold portion of heart that has been "revealed" for rendering

void setup() {
  Serial.begin(9600);

  // OLED Setup
  display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS);
  display.clearDisplay();

  // LIS3DH setup
  lis.begin(0x18);

  // Initialize Filter Buffer
  for (int i=0; i < FILTER_SIZE; i++) {
    filterBuffer[i] = 0;
  }

  // Initialize revealed_bitmap
  for (int i=0; i<512; i++) {
    revealed_bitmap[i] = 0x00;
  }

  // Probably not needed, but paranoid re-intits for reset button push
  stepCount = 0;
  bufferIndex = 0;
  filterIndex = 0;
  lastStepCount = 0;
  lastSwitchTime = 0;
  waitTime = TEXT_TIME;
  isHeartDisplayed = false;

  display.display();
}

void renderStats() {
    int sensorValue = analogRead(BATTERY_PIN);
    float voltage = sensorValue * (REFERENCE_VOLTAGE / 4095.0) * VOLTAGE_DIVIDER_RATIO;

    display.clearDisplay();
    display.setTextSize(1);
    display.setTextColor(SSD1306_WHITE);
    display.setCursor(0, 0);
    display.print("Steps: "); display.print(stepCount);
    display.setCursor(0, 15);
    display.print("Battery: "); display.print(voltage); display.print(" V");
    display.setCursor(0, 30);
    display.print("Calories: "); display.print(stepCount * 0.04);
    display.setCursor(0, 45);
    display.print("Distance: "); display.print(stepCount * 1.5); display.print(" Feet");
    display.display();
}

int renderedByteChunk = 0;
void renderHeart() {
  display.clearDisplay();
  int currentBytes = stepCount % 32;
  if (currentBytes < renderedByteChunk) {  //If we find our steps have overflown the bitmap data, flush revelealed and start again
    for(int i=0; i<512; i++) {
      revealed_bitmap[i] = 0x00;
    }
  }
  renderedByteChunk = currentBytes;

  // copy 16 bytes for each renderedByteChunk from heart_bitmap into reavealed_bitmap
  // originally doing one byte per step meant a LOT of steps to reveal any heart foreground
  for(int i=0; i<renderedByteChunk; i++) {
    for(int j=0; j<16; j++) {
      int k = i*16 + j;
      revealed_bitmap[k] = heart_bitmap[k];
    }
  }

  display.drawBitmap(32, 0, revealed_bitmap, 64, 64, SSD1306_WHITE);
  display.display();
}

void loop() {
  // Get a timestamp
  unsigned long now = millis();

  // Get sensor events, preprocessed into nice accelerations
  // Adafruit for the win with this 
  sensors_event_t event;
  lis.getEvent(&event);

  // Acceleration magnitude
  float accel = sqrt(pow(event.acceleration.x, 2) + pow(event.acceleration.y, 2) + pow(event.acceleration.z, 2));

  // Running average update
  float smoothedAccel = smoothAccel(accel);

  // Add to data sample for processing
  buffer[bufferIndex] = smoothedAccel;
  bufferIndex = (bufferIndex + 1) % accelBufferSize;

  // When buffer is full, run step detection
  if (bufferIndex == 0) {
    lastStepCount = stepCount;
    countPeaks();
  }

  // Check if enough time has passed between screen modes and switch
  if (now - lastSwitchTime >= waitTime) {
    if (isHeartDisplayed) {
      waitTime = TEXT_TIME;
      renderStats();
    }
    else {
      waitTime = HEART_TIME;
      renderHeart();
    }
    isHeartDisplayed = !isHeartDisplayed;
    lastSwitchTime = now;
  }

  // The visuals and data are driven by steps
  // Only update if there is new step-driven data to warrant the cost
  if (stepCount != lastStepCount) {
    if (!isHeartDisplayed) {
      renderStats();
    }
    else {
      renderHeart();
    } 
  }
}

